# Getting started

This section will guide you through setting up your first model and running it in the following four steps

1. Defining your {class}`hydrantic.model.Model` and {class}`hydrantic.model.ModelHparams` class.
2. Defining a {class}`hydrantic.data.Data` and {class}`hydrantic.data.DataHparams` class.
3. Instantiating the model and data classes with their respective hyperparameters.
4. Fitting the model to the data.

### Defining your model

To define a model in hydrantic, we first have to define a hyperparameter class that inherits from {class}`hydrantic.model.ModelHparams` and defines all hyperparameters and their respective types required for instantiating the Model.

```python
...
from hydrantic.model import ModelHparams

class ClassifierHparams(ModelHparams):
    input_dim: int
    hidden_dim: int
    output_dim: int
```

After the hyperparameter class is implemented, we can define a model class that inherits from {class}`hydrantic.model.Model` and uses the hyperparameter class. Importantly, we must pass the hyperparameter class to the {class}`hydrantic.model.Model` class constructor.

```python
...
from hydrantic.model import Model

class Classifier(Model[ClassifierHparams]):  # pass the ClassifierHparams class here
    def __init__(self, hparams: ClassifierHparams):
        # initializing the super class is required to handle the hparams validation
        super().__init__(hparams=hparams)

        # A minimal example
        self.net = torch.nn.Sequential([
            torch.nn.Linear(self.thparams.input_dim, self.thparams.hidden_dim),
            torch.nn.ReLU(),
            torch.nn.Linear(self.thparams.hidden_dim, self.thparams.output_dim)
        ])


    def compute_metrics(self, batch, batch_idx) -> dict[str, Tensor]:
        # Define metric computation here
        x, y = batch
        y_hat = self.net(x)
        loss = torch.nn.functional.mse_loss(y_hat, y)

        return {"loss": loss}
```

The Model class handles the validation of the hyperparameters and their types in the background using pydantics validation mechanism. It provides a typed version of the hyperparameters via its `.thparams` attribute.

The Model must implement the `compute_metrics` method that returns a dictionary of metric names and their corresponding values as torch tensors. The metric that is stored under the _loss_ key is used for optimization.

### Defining your data

Hydrantic offers a basic {class}`hydrantic.data.PyTorchData` class that can be used to define your dataset. It pre-implements some basic features such as random splitting in training, validation and test datasets and configuration of dataloaders for the datasets. Similar as before, it requires a hyperparameter class that inherits from {class}`hydrantic.data.DataHparams` and defines all hyperparameters and their respective types required for instantiating the Data class.

```python
...
from hydrantic.data import DataHparams


class ClassificationDataHparams(DataHparams):
    num_samples: int
    data_dim: int
    num_classes: int
```

The Data class has to implement the `get_dataset` method that returns a `Dataset` object.

```python
...
from hydrantic.data import PyTorchData


class ClassificationData(PyTorchData[ClassificationDataHparams]):
    def get_dataset(self) -> TensorDataset:
        X = torch.randn(self.thparams.num_samples, self.thparams.data_dim)
        y = torch.randint(0, self.thparams.num_classes, (self.thparams.num_samples,))
        return TensorDataset(X, y)
```

The `train`, `test`, and `validation` attributes of the data class contain subsets that are automatically generated by the {class}`hydrantic.data.PyTorchData` class. Splitting can be configured via the hyperparameters available in the {class}`hydrantic.data.DataHparams` class.

Furthermore, in case loader hyperparameters are specified in the {class}`hydratic.data.hparams.DataHparams` class, the data class will automatically generate dataloaders for each subset and expose them via its `train_loader`, `val_loader`, and `test_loader` attributes.

### Creating data and model instances

To instantiate the data and model classes, simply create instances of their hyperparameters and pass them to the respective classes.

```python
data_hparams = ClassificationDataHparams(num_samples=1000, data_dim=10, num_classes=2)
data = ClassificationData(data_hparams)

model_hparams = ClassifierHparams(input_dim=10, hidden_dim=128, output_dim=2)
model = Classifier(model_hparams)
```

As mentioned earlier, we can also specify loader hyperparameters in the `ClassificationDataHparams` class. This allows us to configure the dataloaders for each subset of the data.

```python
data_hparams = ClassificationDataHparams(
    num_samples=1000,
    data_dim=10,
    num_classes=2,
    loader=dict(
        batch_size=46,
        shuffle=True
    )
)
```

When loader hyperparameters are specified, the loaders for each of the subset will be available via their respective attributes.

### Fitting your model

The {class}`hydrantic.model.Model` class has a simple `fit_fast` method, that allows to quickly fit a model. Since customization capabilities of this method are rather limited, it is recommended to use it only for debugging or simple experiments. For more complex training the {mod}`hydrantic.cli` module should be used. The `fit_fast` method uses the Adam optimizer.

```python
model.fit_fast(
    train_loader=data.train_loader,
    n_epochs=10,
    lr=1e-3,
    accelerator="gpu",
)
```
